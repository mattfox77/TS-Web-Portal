/**
 * Database Backup Script
 * 
 * This script exports all tables from the Cloudflare D1 database to SQL format
 * and uploads the backup to R2 storage with a timestamp.
 * 
 * Usage:
 * - As a standalone script: npx tsx scripts/backup-database.ts
 * - As an API endpoint: Called from /api/admin/backup
 * - As a scheduled job: Triggered by Cloudflare Cron
 */

interface Env {
  DB: D1Database;
  DOCUMENTS: R2Bucket;
}

interface BackupResult {
  success: boolean;
  backupKey: string;
  timestamp: string;
  size: number;
  tables: string[];
  error?: string;
}

// List of all tables to backup in dependency order
const TABLES_TO_BACKUP = [
  'clients',
  'users',
  'service_packages',
  'subscriptions',
  'projects',
  'tickets',
  'ticket_comments',
  'invoices',
  'invoice_items',
  'payments',
  'documents',
  'api_usage',
  'activity_log',
];

/**
 * Escapes SQL string values to prevent injection and handle special characters
 */
function escapeSqlValue(value: any): string {
  if (value === null || value === undefined) {
    return 'NULL';
  }
  
  if (typeof value === 'number') {
    return value.toString();
  }
  
  if (typeof value === 'boolean') {
    return value ? '1' : '0';
  }
  
  // Escape single quotes by doubling them
  const stringValue = String(value).replace(/'/g, "''");
  return `'${stringValue}'`;
}

/**
 * Generates INSERT statements for a table's data
 */
function generateInsertStatements(tableName: string, rows: any[]): string {
  if (rows.length === 0) {
    return `-- No data in table: ${tableName}\n\n`;
  }
  
  let sql = `-- Data for table: ${tableName}\n`;
  sql += `-- ${rows.length} rows\n`;
  
  // Get column names from first row
  const columns = Object.keys(rows[0]);
  const columnList = columns.join(', ');
  
  // Generate INSERT statements
  for (const row of rows) {
    const values = columns.map(col => escapeSqlValue(row[col])).join(', ');
    sql += `INSERT INTO ${tableName} (${columnList}) VALUES (${values});\n`;
  }
  
  sql += '\n';
  return sql;
}

/**
 * Exports all data from a single table
 */
async function exportTable(db: D1Database, tableName: string): Promise<string> {
  try {
    const { results } = await db.prepare(`SELECT * FROM ${tableName}`).all();
    return generateInsertStatements(tableName, results || []);
  } catch (error) {
    console.error(`Error exporting table ${tableName}:`, error);
    return `-- Error exporting table: ${tableName}\n-- ${error}\n\n`;
  }
}

/**
 * Creates a complete database backup
 */
export async function backupDatabase(env: Env): Promise<BackupResult> {
  const timestamp = new Date().toISOString();
  const dateStr = timestamp.split('T')[0]; // YYYY-MM-DD
  const timeStr = timestamp.split('T')[1].split('.')[0].replace(/:/g, '-'); // HH-MM-SS
  const backupKey = `backups/database-${dateStr}-${timeStr}.sql`;
  
  console.log(`Starting database backup: ${backupKey}`);
  
  try {
    // Build SQL dump
    let sqlDump = `-- Tech Support Client Portal Database Backup\n`;
    sqlDump += `-- Backup Date: ${timestamp}\n`;
    sqlDump += `-- Generated by backup-database.ts\n\n`;
    sqlDump += `-- To restore this backup:\n`;
    sqlDump += `-- 1. Download this file from R2 storage\n`;
    sqlDump += `-- 2. Run: npx wrangler d1 execute <database-name> --remote --file=<backup-file>\n\n`;
    
    // Add PRAGMA settings for better import performance
    sqlDump += `PRAGMA foreign_keys = OFF;\n`;
    sqlDump += `BEGIN TRANSACTION;\n\n`;
    
    // Export each table
    const exportedTables: string[] = [];
    for (const tableName of TABLES_TO_BACKUP) {
      console.log(`Exporting table: ${tableName}`);
      const tableData = await exportTable(env.DB, tableName);
      sqlDump += tableData;
      exportedTables.push(tableName);
    }
    
    // Close transaction
    sqlDump += `COMMIT;\n`;
    sqlDump += `PRAGMA foreign_keys = ON;\n`;
    
    // Calculate size
    const backupSize = new TextEncoder().encode(sqlDump).length;
    console.log(`Backup size: ${(backupSize / 1024).toFixed(2)} KB`);
    
    // Upload to R2
    console.log(`Uploading backup to R2: ${backupKey}`);
    await env.DOCUMENTS.put(backupKey, sqlDump, {
      customMetadata: {
        'backup-timestamp': timestamp,
        'backup-size': backupSize.toString(),
        'tables-count': exportedTables.length.toString(),
      },
    });
    
    console.log('Backup completed successfully');
    
    return {
      success: true,
      backupKey,
      timestamp,
      size: backupSize,
      tables: exportedTables,
    };
  } catch (error) {
    console.error('Backup failed:', error);
    return {
      success: false,
      backupKey,
      timestamp,
      size: 0,
      tables: [],
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Cleans up old backups (older than 30 days)
 */
export async function cleanupOldBackups(bucket: R2Bucket): Promise<number> {
  console.log('Starting cleanup of old backups...');
  
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  
  let deletedCount = 0;
  
  try {
    // List all backup files
    const listed = await bucket.list({ prefix: 'backups/' });
    
    for (const object of listed.objects) {
      // Check if backup is older than 30 days
      if (object.uploaded < thirtyDaysAgo) {
        console.log(`Deleting old backup: ${object.key} (uploaded: ${object.uploaded.toISOString()})`);
        await bucket.delete(object.key);
        deletedCount++;
      }
    }
    
    console.log(`Cleanup completed: ${deletedCount} old backups deleted`);
  } catch (error) {
    console.error('Cleanup failed:', error);
  }
  
  return deletedCount;
}

/**
 * Main function for standalone execution
 */
async function main() {
  // This would be called from an API route or Cloudflare Worker
  // For standalone testing, you would need to provide env bindings
  console.log('Database backup script');
  console.log('This script should be called from an API route or Cloudflare Worker');
  console.log('with proper D1 and R2 bindings.');
}

// Only run main if this is the entry point
if (require.main === module) {
  main().catch(console.error);
}
